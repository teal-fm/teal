// @generated - This file is generated by esquema-codegen (forked from atrium-codegen). DO NOT EDIT.
//!Structs for ATP client, implements all HTTP APIs of XRPC.
///Client struct for the ATP service.
pub struct AtpServiceClient<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub service: Service<T>,
}
impl<T> AtpServiceClient<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub fn new(xrpc: T) -> Self {
        Self {
            service: Service::new(std::sync::Arc::new(xrpc)),
        }
    }
}
pub struct Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    pub app: app::Service<T>,
    pub chat: chat::Service<T>,
    pub com: com::Service<T>,
    pub fm: fm::Service<T>,
    pub tools: tools::Service<T>,
    pub(crate) _phantom: core::marker::PhantomData<T>,
}
pub mod app {
    pub struct Service<T>
    where
        T: atrium_xrpc::XrpcClient + Send + Sync,
    {
        pub bsky: bsky::Service<T>,
        pub(crate) _phantom: core::marker::PhantomData<T>,
    }
    pub mod bsky {
        pub struct Service<T>
        where
            T: atrium_xrpc::XrpcClient + Send + Sync,
        {
            pub actor: actor::Service<T>,
            pub feed: feed::Service<T>,
            pub graph: graph::Service<T>,
            pub labeler: labeler::Service<T>,
            pub notification: notification::Service<T>,
            pub unspecced: unspecced::Service<T>,
            pub video: video::Service<T>,
            pub(crate) _phantom: core::marker::PhantomData<T>,
        }
        pub mod actor {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod feed {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod graph {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod labeler {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod notification {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod unspecced {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod video {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
    }
}
pub mod chat {
    pub struct Service<T>
    where
        T: atrium_xrpc::XrpcClient + Send + Sync,
    {
        pub bsky: bsky::Service<T>,
        pub(crate) _phantom: core::marker::PhantomData<T>,
    }
    pub mod bsky {
        pub struct Service<T>
        where
            T: atrium_xrpc::XrpcClient + Send + Sync,
        {
            pub actor: actor::Service<T>,
            pub convo: convo::Service<T>,
            pub moderation: moderation::Service<T>,
            pub(crate) _phantom: core::marker::PhantomData<T>,
        }
        pub mod actor {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod convo {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod moderation {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
    }
}
pub mod com {
    pub struct Service<T>
    where
        T: atrium_xrpc::XrpcClient + Send + Sync,
    {
        pub atproto: atproto::Service<T>,
        pub(crate) _phantom: core::marker::PhantomData<T>,
    }
    pub mod atproto {
        pub struct Service<T>
        where
            T: atrium_xrpc::XrpcClient + Send + Sync,
        {
            pub admin: admin::Service<T>,
            pub identity: identity::Service<T>,
            pub label: label::Service<T>,
            pub moderation: moderation::Service<T>,
            pub repo: repo::Service<T>,
            pub server: server::Service<T>,
            pub sync: sync::Service<T>,
            pub temp: temp::Service<T>,
            pub(crate) _phantom: core::marker::PhantomData<T>,
        }
        pub mod admin {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod identity {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod label {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod moderation {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod repo {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod server {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod sync {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod temp {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
    }
}
pub mod fm {
    pub struct Service<T>
    where
        T: atrium_xrpc::XrpcClient + Send + Sync,
    {
        pub teal: teal::Service<T>,
        pub(crate) _phantom: core::marker::PhantomData<T>,
    }
    pub mod teal {
        pub struct Service<T>
        where
            T: atrium_xrpc::XrpcClient + Send + Sync,
        {
            pub alpha: alpha::Service<T>,
            pub(crate) _phantom: core::marker::PhantomData<T>,
        }
        pub mod alpha {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub actor: actor::Service<T>,
                pub feed: feed::Service<T>,
                pub stats: stats::Service<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
            pub mod actor {
                pub struct Service<T>
                where
                    T: atrium_xrpc::XrpcClient + Send + Sync,
                {
                    pub(crate) xrpc: std::sync::Arc<T>,
                    pub(crate) _phantom: core::marker::PhantomData<T>,
                }
            }
            pub mod feed {
                pub struct Service<T>
                where
                    T: atrium_xrpc::XrpcClient + Send + Sync,
                {
                    pub(crate) xrpc: std::sync::Arc<T>,
                    pub(crate) _phantom: core::marker::PhantomData<T>,
                }
            }
            pub mod stats {
                pub struct Service<T>
                where
                    T: atrium_xrpc::XrpcClient + Send + Sync,
                {
                    pub(crate) xrpc: std::sync::Arc<T>,
                    pub(crate) _phantom: core::marker::PhantomData<T>,
                }
            }
        }
    }
}
pub mod tools {
    pub struct Service<T>
    where
        T: atrium_xrpc::XrpcClient + Send + Sync,
    {
        pub ozone: ozone::Service<T>,
        pub(crate) _phantom: core::marker::PhantomData<T>,
    }
    pub mod ozone {
        pub struct Service<T>
        where
            T: atrium_xrpc::XrpcClient + Send + Sync,
        {
            pub communication: communication::Service<T>,
            pub moderation: moderation::Service<T>,
            pub server: server::Service<T>,
            pub set: set::Service<T>,
            pub setting: setting::Service<T>,
            pub signature: signature::Service<T>,
            pub team: team::Service<T>,
            pub(crate) _phantom: core::marker::PhantomData<T>,
        }
        pub mod communication {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod moderation {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod server {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod set {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod setting {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod signature {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
        pub mod team {
            pub struct Service<T>
            where
                T: atrium_xrpc::XrpcClient + Send + Sync,
            {
                pub(crate) xrpc: std::sync::Arc<T>,
                pub(crate) _phantom: core::marker::PhantomData<T>,
            }
        }
    }
}
impl<T> self::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            app: app::Service::new(std::sync::Arc::clone(&xrpc)),
            chat: chat::Service::new(std::sync::Arc::clone(&xrpc)),
            com: com::Service::new(std::sync::Arc::clone(&xrpc)),
            fm: fm::Service::new(std::sync::Arc::clone(&xrpc)),
            tools: tools::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
impl<T> app::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            bsky: app::bsky::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
impl<T> app::bsky::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            actor: app::bsky::actor::Service::new(std::sync::Arc::clone(&xrpc)),
            feed: app::bsky::feed::Service::new(std::sync::Arc::clone(&xrpc)),
            graph: app::bsky::graph::Service::new(std::sync::Arc::clone(&xrpc)),
            labeler: app::bsky::labeler::Service::new(std::sync::Arc::clone(&xrpc)),
            notification: app::bsky::notification::Service::new(
                std::sync::Arc::clone(&xrpc),
            ),
            unspecced: app::bsky::unspecced::Service::new(std::sync::Arc::clone(&xrpc)),
            video: app::bsky::video::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
impl<T> app::bsky::actor::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Get private preferences attached to the current account. Expected use is synchronization between multiple devices, and import/export during account migration. Requires auth.
    pub async fn get_preferences(
        &self,
        params: crate::app::bsky::actor::get_preferences::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::actor::get_preferences::Output,
        crate::app::bsky::actor::get_preferences::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::actor::get_preferences::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get detailed profile view of an actor. Does not require auth, but contains relevant metadata with auth.
    pub async fn get_profile(
        &self,
        params: crate::app::bsky::actor::get_profile::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::actor::get_profile::Output,
        crate::app::bsky::actor::get_profile::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::actor::get_profile::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get detailed profile views of multiple actors.
    pub async fn get_profiles(
        &self,
        params: crate::app::bsky::actor::get_profiles::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::actor::get_profiles::Output,
        crate::app::bsky::actor::get_profiles::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::actor::get_profiles::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of suggested actors. Expected use is discovery of accounts to follow during new account onboarding.
    pub async fn get_suggestions(
        &self,
        params: crate::app::bsky::actor::get_suggestions::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::actor::get_suggestions::Output,
        crate::app::bsky::actor::get_suggestions::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::actor::get_suggestions::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Set the private preferences attached to the account.
    pub async fn put_preferences(
        &self,
        input: crate::app::bsky::actor::put_preferences::Input,
    ) -> atrium_xrpc::Result<(), crate::app::bsky::actor::put_preferences::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::app::bsky::actor::put_preferences::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Find actors (profiles) matching search criteria. Does not require auth.
    pub async fn search_actors(
        &self,
        params: crate::app::bsky::actor::search_actors::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::actor::search_actors::Output,
        crate::app::bsky::actor::search_actors::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::actor::search_actors::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Find actor suggestions for a prefix search term. Expected use is for auto-completion during text field entry. Does not require auth.
    pub async fn search_actors_typeahead(
        &self,
        params: crate::app::bsky::actor::search_actors_typeahead::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::actor::search_actors_typeahead::Output,
        crate::app::bsky::actor::search_actors_typeahead::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::actor::search_actors_typeahead::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> app::bsky::feed::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Get information about a feed generator, including policies and offered feed URIs. Does not require auth; implemented by Feed Generator services (not App View).
    pub async fn describe_feed_generator(
        &self,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::feed::describe_feed_generator::Output,
        crate::app::bsky::feed::describe_feed_generator::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::feed::describe_feed_generator::NSID.into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of feeds (feed generator records) created by the actor (in the actor's repo).
    pub async fn get_actor_feeds(
        &self,
        params: crate::app::bsky::feed::get_actor_feeds::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::feed::get_actor_feeds::Output,
        crate::app::bsky::feed::get_actor_feeds::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::feed::get_actor_feeds::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of posts liked by an actor. Requires auth, actor must be the requesting account.
    pub async fn get_actor_likes(
        &self,
        params: crate::app::bsky::feed::get_actor_likes::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::feed::get_actor_likes::Output,
        crate::app::bsky::feed::get_actor_likes::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::feed::get_actor_likes::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get a view of an actor's 'author feed' (post and reposts by the author). Does not require auth.
    pub async fn get_author_feed(
        &self,
        params: crate::app::bsky::feed::get_author_feed::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::feed::get_author_feed::Output,
        crate::app::bsky::feed::get_author_feed::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::feed::get_author_feed::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get a hydrated feed from an actor's selected feed generator. Implemented by App View.
    pub async fn get_feed(
        &self,
        params: crate::app::bsky::feed::get_feed::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::feed::get_feed::Output,
        crate::app::bsky::feed::get_feed::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::feed::get_feed::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get information about a feed generator. Implemented by AppView.
    pub async fn get_feed_generator(
        &self,
        params: crate::app::bsky::feed::get_feed_generator::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::feed::get_feed_generator::Output,
        crate::app::bsky::feed::get_feed_generator::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::feed::get_feed_generator::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get information about a list of feed generators.
    pub async fn get_feed_generators(
        &self,
        params: crate::app::bsky::feed::get_feed_generators::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::feed::get_feed_generators::Output,
        crate::app::bsky::feed::get_feed_generators::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::feed::get_feed_generators::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get a skeleton of a feed provided by a feed generator. Auth is optional, depending on provider requirements, and provides the DID of the requester. Implemented by Feed Generator Service.
    pub async fn get_feed_skeleton(
        &self,
        params: crate::app::bsky::feed::get_feed_skeleton::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::feed::get_feed_skeleton::Output,
        crate::app::bsky::feed::get_feed_skeleton::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::feed::get_feed_skeleton::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get like records which reference a subject (by AT-URI and CID).
    pub async fn get_likes(
        &self,
        params: crate::app::bsky::feed::get_likes::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::feed::get_likes::Output,
        crate::app::bsky::feed::get_likes::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::feed::get_likes::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get a feed of recent posts from a list (posts and reposts from any actors on the list). Does not require auth.
    pub async fn get_list_feed(
        &self,
        params: crate::app::bsky::feed::get_list_feed::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::feed::get_list_feed::Output,
        crate::app::bsky::feed::get_list_feed::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::feed::get_list_feed::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get posts in a thread. Does not require auth, but additional metadata and filtering will be applied for authed requests.
    pub async fn get_post_thread(
        &self,
        params: crate::app::bsky::feed::get_post_thread::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::feed::get_post_thread::Output,
        crate::app::bsky::feed::get_post_thread::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::feed::get_post_thread::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Gets post views for a specified list of posts (by AT-URI). This is sometimes referred to as 'hydrating' a 'feed skeleton'.
    pub async fn get_posts(
        &self,
        params: crate::app::bsky::feed::get_posts::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::feed::get_posts::Output,
        crate::app::bsky::feed::get_posts::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::feed::get_posts::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of quotes for a given post.
    pub async fn get_quotes(
        &self,
        params: crate::app::bsky::feed::get_quotes::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::feed::get_quotes::Output,
        crate::app::bsky::feed::get_quotes::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::feed::get_quotes::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of reposts for a given post.
    pub async fn get_reposted_by(
        &self,
        params: crate::app::bsky::feed::get_reposted_by::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::feed::get_reposted_by::Output,
        crate::app::bsky::feed::get_reposted_by::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::feed::get_reposted_by::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of suggested feeds (feed generators) for the requesting account.
    pub async fn get_suggested_feeds(
        &self,
        params: crate::app::bsky::feed::get_suggested_feeds::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::feed::get_suggested_feeds::Output,
        crate::app::bsky::feed::get_suggested_feeds::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::feed::get_suggested_feeds::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get a view of the requesting account's home timeline. This is expected to be some form of reverse-chronological feed.
    pub async fn get_timeline(
        &self,
        params: crate::app::bsky::feed::get_timeline::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::feed::get_timeline::Output,
        crate::app::bsky::feed::get_timeline::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::feed::get_timeline::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Find posts matching search criteria, returning views of those posts.
    pub async fn search_posts(
        &self,
        params: crate::app::bsky::feed::search_posts::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::feed::search_posts::Output,
        crate::app::bsky::feed::search_posts::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::feed::search_posts::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Send information about interactions with feed items back to the feed generator that served them.
    pub async fn send_interactions(
        &self,
        input: crate::app::bsky::feed::send_interactions::Input,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::feed::send_interactions::Output,
        crate::app::bsky::feed::send_interactions::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::app::bsky::feed::send_interactions::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> app::bsky::graph::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Get a list of starter packs created by the actor.
    pub async fn get_actor_starter_packs(
        &self,
        params: crate::app::bsky::graph::get_actor_starter_packs::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::graph::get_actor_starter_packs::Output,
        crate::app::bsky::graph::get_actor_starter_packs::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::graph::get_actor_starter_packs::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Enumerates which accounts the requesting account is currently blocking. Requires auth.
    pub async fn get_blocks(
        &self,
        params: crate::app::bsky::graph::get_blocks::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::graph::get_blocks::Output,
        crate::app::bsky::graph::get_blocks::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::graph::get_blocks::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Enumerates accounts which follow a specified account (actor).
    pub async fn get_followers(
        &self,
        params: crate::app::bsky::graph::get_followers::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::graph::get_followers::Output,
        crate::app::bsky::graph::get_followers::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::graph::get_followers::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Enumerates accounts which a specified account (actor) follows.
    pub async fn get_follows(
        &self,
        params: crate::app::bsky::graph::get_follows::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::graph::get_follows::Output,
        crate::app::bsky::graph::get_follows::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::graph::get_follows::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Enumerates accounts which follow a specified account (actor) and are followed by the viewer.
    pub async fn get_known_followers(
        &self,
        params: crate::app::bsky::graph::get_known_followers::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::graph::get_known_followers::Output,
        crate::app::bsky::graph::get_known_followers::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::graph::get_known_followers::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Gets a 'view' (with additional context) of a specified list.
    pub async fn get_list(
        &self,
        params: crate::app::bsky::graph::get_list::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::graph::get_list::Output,
        crate::app::bsky::graph::get_list::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::graph::get_list::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get mod lists that the requesting account (actor) is blocking. Requires auth.
    pub async fn get_list_blocks(
        &self,
        params: crate::app::bsky::graph::get_list_blocks::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::graph::get_list_blocks::Output,
        crate::app::bsky::graph::get_list_blocks::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::graph::get_list_blocks::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Enumerates mod lists that the requesting account (actor) currently has muted. Requires auth.
    pub async fn get_list_mutes(
        &self,
        params: crate::app::bsky::graph::get_list_mutes::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::graph::get_list_mutes::Output,
        crate::app::bsky::graph::get_list_mutes::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::graph::get_list_mutes::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Enumerates the lists created by a specified account (actor).
    pub async fn get_lists(
        &self,
        params: crate::app::bsky::graph::get_lists::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::graph::get_lists::Output,
        crate::app::bsky::graph::get_lists::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::graph::get_lists::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Enumerates accounts that the requesting account (actor) currently has muted. Requires auth.
    pub async fn get_mutes(
        &self,
        params: crate::app::bsky::graph::get_mutes::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::graph::get_mutes::Output,
        crate::app::bsky::graph::get_mutes::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::graph::get_mutes::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Enumerates public relationships between one account, and a list of other accounts. Does not require auth.
    pub async fn get_relationships(
        &self,
        params: crate::app::bsky::graph::get_relationships::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::graph::get_relationships::Output,
        crate::app::bsky::graph::get_relationships::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::graph::get_relationships::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Gets a view of a starter pack.
    pub async fn get_starter_pack(
        &self,
        params: crate::app::bsky::graph::get_starter_pack::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::graph::get_starter_pack::Output,
        crate::app::bsky::graph::get_starter_pack::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::graph::get_starter_pack::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get views for a list of starter packs.
    pub async fn get_starter_packs(
        &self,
        params: crate::app::bsky::graph::get_starter_packs::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::graph::get_starter_packs::Output,
        crate::app::bsky::graph::get_starter_packs::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::graph::get_starter_packs::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Enumerates follows similar to a given account (actor). Expected use is to recommend additional accounts immediately after following one account.
    pub async fn get_suggested_follows_by_actor(
        &self,
        params: crate::app::bsky::graph::get_suggested_follows_by_actor::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::graph::get_suggested_follows_by_actor::Output,
        crate::app::bsky::graph::get_suggested_follows_by_actor::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::graph::get_suggested_follows_by_actor::NSID
                        .into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Creates a mute relationship for the specified account. Mutes are private in Bluesky. Requires auth.
    pub async fn mute_actor(
        &self,
        input: crate::app::bsky::graph::mute_actor::Input,
    ) -> atrium_xrpc::Result<(), crate::app::bsky::graph::mute_actor::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::app::bsky::graph::mute_actor::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Creates a mute relationship for the specified list of accounts. Mutes are private in Bluesky. Requires auth.
    pub async fn mute_actor_list(
        &self,
        input: crate::app::bsky::graph::mute_actor_list::Input,
    ) -> atrium_xrpc::Result<(), crate::app::bsky::graph::mute_actor_list::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::app::bsky::graph::mute_actor_list::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Mutes a thread preventing notifications from the thread and any of its children. Mutes are private in Bluesky. Requires auth.
    pub async fn mute_thread(
        &self,
        input: crate::app::bsky::graph::mute_thread::Input,
    ) -> atrium_xrpc::Result<(), crate::app::bsky::graph::mute_thread::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::app::bsky::graph::mute_thread::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Find starter packs matching search criteria. Does not require auth.
    pub async fn search_starter_packs(
        &self,
        params: crate::app::bsky::graph::search_starter_packs::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::graph::search_starter_packs::Output,
        crate::app::bsky::graph::search_starter_packs::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::graph::search_starter_packs::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Unmutes the specified account. Requires auth.
    pub async fn unmute_actor(
        &self,
        input: crate::app::bsky::graph::unmute_actor::Input,
    ) -> atrium_xrpc::Result<(), crate::app::bsky::graph::unmute_actor::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::app::bsky::graph::unmute_actor::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Unmutes the specified list of accounts. Requires auth.
    pub async fn unmute_actor_list(
        &self,
        input: crate::app::bsky::graph::unmute_actor_list::Input,
    ) -> atrium_xrpc::Result<(), crate::app::bsky::graph::unmute_actor_list::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::app::bsky::graph::unmute_actor_list::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Unmutes the specified thread. Requires auth.
    pub async fn unmute_thread(
        &self,
        input: crate::app::bsky::graph::unmute_thread::Input,
    ) -> atrium_xrpc::Result<(), crate::app::bsky::graph::unmute_thread::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::app::bsky::graph::unmute_thread::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> app::bsky::labeler::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Get information about a list of labeler services.
    pub async fn get_services(
        &self,
        params: crate::app::bsky::labeler::get_services::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::labeler::get_services::Output,
        crate::app::bsky::labeler::get_services::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::labeler::get_services::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> app::bsky::notification::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Count the number of unread notifications for the requesting account. Requires auth.
    pub async fn get_unread_count(
        &self,
        params: crate::app::bsky::notification::get_unread_count::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::notification::get_unread_count::Output,
        crate::app::bsky::notification::get_unread_count::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::notification::get_unread_count::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Enumerate notifications for the requesting account. Requires auth.
    pub async fn list_notifications(
        &self,
        params: crate::app::bsky::notification::list_notifications::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::notification::list_notifications::Output,
        crate::app::bsky::notification::list_notifications::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::notification::list_notifications::NSID
                        .into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Set notification-related preferences for an account. Requires auth.
    pub async fn put_preferences(
        &self,
        input: crate::app::bsky::notification::put_preferences::Input,
    ) -> atrium_xrpc::Result<
        (),
        crate::app::bsky::notification::put_preferences::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::app::bsky::notification::put_preferences::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Register to receive push notifications, via a specified service, for the requesting account. Requires auth.
    pub async fn register_push(
        &self,
        input: crate::app::bsky::notification::register_push::Input,
    ) -> atrium_xrpc::Result<(), crate::app::bsky::notification::register_push::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::app::bsky::notification::register_push::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Notify server that the requesting account has seen notifications. Requires auth.
    pub async fn update_seen(
        &self,
        input: crate::app::bsky::notification::update_seen::Input,
    ) -> atrium_xrpc::Result<(), crate::app::bsky::notification::update_seen::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::app::bsky::notification::update_seen::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> app::bsky::unspecced::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Get miscellaneous runtime configuration.
    pub async fn get_config(
        &self,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::unspecced::get_config::Output,
        crate::app::bsky::unspecced::get_config::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::unspecced::get_config::NSID.into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///An unspecced view of globally popular feed generators.
    pub async fn get_popular_feed_generators(
        &self,
        params: crate::app::bsky::unspecced::get_popular_feed_generators::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::unspecced::get_popular_feed_generators::Output,
        crate::app::bsky::unspecced::get_popular_feed_generators::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::unspecced::get_popular_feed_generators::NSID
                        .into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get a skeleton of suggested actors. Intended to be called and then hydrated through app.bsky.actor.getSuggestions
    pub async fn get_suggestions_skeleton(
        &self,
        params: crate::app::bsky::unspecced::get_suggestions_skeleton::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::unspecced::get_suggestions_skeleton::Output,
        crate::app::bsky::unspecced::get_suggestions_skeleton::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::unspecced::get_suggestions_skeleton::NSID
                        .into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of suggestions (feeds and users) tagged with categories
    pub async fn get_tagged_suggestions(
        &self,
        params: crate::app::bsky::unspecced::get_tagged_suggestions::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::unspecced::get_tagged_suggestions::Output,
        crate::app::bsky::unspecced::get_tagged_suggestions::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::unspecced::get_tagged_suggestions::NSID
                        .into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get a list of trending topics
    pub async fn get_trending_topics(
        &self,
        params: crate::app::bsky::unspecced::get_trending_topics::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::unspecced::get_trending_topics::Output,
        crate::app::bsky::unspecced::get_trending_topics::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::unspecced::get_trending_topics::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Backend Actors (profile) search, returns only skeleton.
    pub async fn search_actors_skeleton(
        &self,
        params: crate::app::bsky::unspecced::search_actors_skeleton::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::unspecced::search_actors_skeleton::Output,
        crate::app::bsky::unspecced::search_actors_skeleton::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::unspecced::search_actors_skeleton::NSID
                        .into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Backend Posts search, returns only skeleton
    pub async fn search_posts_skeleton(
        &self,
        params: crate::app::bsky::unspecced::search_posts_skeleton::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::unspecced::search_posts_skeleton::Output,
        crate::app::bsky::unspecced::search_posts_skeleton::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::unspecced::search_posts_skeleton::NSID
                        .into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Backend Starter Pack search, returns only skeleton.
    pub async fn search_starter_packs_skeleton(
        &self,
        params: crate::app::bsky::unspecced::search_starter_packs_skeleton::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::unspecced::search_starter_packs_skeleton::Output,
        crate::app::bsky::unspecced::search_starter_packs_skeleton::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::unspecced::search_starter_packs_skeleton::NSID
                        .into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> app::bsky::video::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Get status details for a video processing job.
    pub async fn get_job_status(
        &self,
        params: crate::app::bsky::video::get_job_status::Parameters,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::video::get_job_status::Output,
        crate::app::bsky::video::get_job_status::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::video::get_job_status::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get video upload limits for the authenticated user.
    pub async fn get_upload_limits(
        &self,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::video::get_upload_limits::Output,
        crate::app::bsky::video::get_upload_limits::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::app::bsky::video::get_upload_limits::NSID.into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Upload a video to be processed then stored on the PDS.
    pub async fn upload_video(
        &self,
        input: Vec<u8>,
    ) -> atrium_xrpc::Result<
        crate::app::bsky::video::upload_video::Output,
        crate::app::bsky::video::upload_video::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                Vec<u8>,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::app::bsky::video::upload_video::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Bytes(input)),
                    encoding: Some(String::from("video/mp4")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> chat::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            bsky: chat::bsky::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
impl<T> chat::bsky::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            actor: chat::bsky::actor::Service::new(std::sync::Arc::clone(&xrpc)),
            convo: chat::bsky::convo::Service::new(std::sync::Arc::clone(&xrpc)),
            moderation: chat::bsky::moderation::Service::new(
                std::sync::Arc::clone(&xrpc),
            ),
            _phantom: core::marker::PhantomData,
        }
    }
}
impl<T> chat::bsky::actor::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    pub async fn delete_account(
        &self,
    ) -> atrium_xrpc::Result<
        crate::chat::bsky::actor::delete_account::Output,
        crate::chat::bsky::actor::delete_account::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::chat::bsky::actor::delete_account::NSID.into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn export_account_data(
        &self,
    ) -> atrium_xrpc::Result<
        Vec<u8>,
        crate::chat::bsky::actor::export_account_data::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::chat::bsky::actor::export_account_data::NSID.into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(bytes) => Ok(bytes),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> chat::bsky::convo::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    pub async fn delete_message_for_self(
        &self,
        input: crate::chat::bsky::convo::delete_message_for_self::Input,
    ) -> atrium_xrpc::Result<
        crate::chat::bsky::convo::delete_message_for_self::Output,
        crate::chat::bsky::convo::delete_message_for_self::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::chat::bsky::convo::delete_message_for_self::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn get_convo(
        &self,
        params: crate::chat::bsky::convo::get_convo::Parameters,
    ) -> atrium_xrpc::Result<
        crate::chat::bsky::convo::get_convo::Output,
        crate::chat::bsky::convo::get_convo::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::chat::bsky::convo::get_convo::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn get_convo_for_members(
        &self,
        params: crate::chat::bsky::convo::get_convo_for_members::Parameters,
    ) -> atrium_xrpc::Result<
        crate::chat::bsky::convo::get_convo_for_members::Output,
        crate::chat::bsky::convo::get_convo_for_members::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::chat::bsky::convo::get_convo_for_members::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn get_log(
        &self,
        params: crate::chat::bsky::convo::get_log::Parameters,
    ) -> atrium_xrpc::Result<
        crate::chat::bsky::convo::get_log::Output,
        crate::chat::bsky::convo::get_log::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::chat::bsky::convo::get_log::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn get_messages(
        &self,
        params: crate::chat::bsky::convo::get_messages::Parameters,
    ) -> atrium_xrpc::Result<
        crate::chat::bsky::convo::get_messages::Output,
        crate::chat::bsky::convo::get_messages::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::chat::bsky::convo::get_messages::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn leave_convo(
        &self,
        input: crate::chat::bsky::convo::leave_convo::Input,
    ) -> atrium_xrpc::Result<
        crate::chat::bsky::convo::leave_convo::Output,
        crate::chat::bsky::convo::leave_convo::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::chat::bsky::convo::leave_convo::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn list_convos(
        &self,
        params: crate::chat::bsky::convo::list_convos::Parameters,
    ) -> atrium_xrpc::Result<
        crate::chat::bsky::convo::list_convos::Output,
        crate::chat::bsky::convo::list_convos::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::chat::bsky::convo::list_convos::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn mute_convo(
        &self,
        input: crate::chat::bsky::convo::mute_convo::Input,
    ) -> atrium_xrpc::Result<
        crate::chat::bsky::convo::mute_convo::Output,
        crate::chat::bsky::convo::mute_convo::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::chat::bsky::convo::mute_convo::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn send_message(
        &self,
        input: crate::chat::bsky::convo::send_message::Input,
    ) -> atrium_xrpc::Result<
        crate::chat::bsky::convo::send_message::Output,
        crate::chat::bsky::convo::send_message::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::chat::bsky::convo::send_message::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn send_message_batch(
        &self,
        input: crate::chat::bsky::convo::send_message_batch::Input,
    ) -> atrium_xrpc::Result<
        crate::chat::bsky::convo::send_message_batch::Output,
        crate::chat::bsky::convo::send_message_batch::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::chat::bsky::convo::send_message_batch::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn unmute_convo(
        &self,
        input: crate::chat::bsky::convo::unmute_convo::Input,
    ) -> atrium_xrpc::Result<
        crate::chat::bsky::convo::unmute_convo::Output,
        crate::chat::bsky::convo::unmute_convo::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::chat::bsky::convo::unmute_convo::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn update_read(
        &self,
        input: crate::chat::bsky::convo::update_read::Input,
    ) -> atrium_xrpc::Result<
        crate::chat::bsky::convo::update_read::Output,
        crate::chat::bsky::convo::update_read::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::chat::bsky::convo::update_read::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> chat::bsky::moderation::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    pub async fn get_actor_metadata(
        &self,
        params: crate::chat::bsky::moderation::get_actor_metadata::Parameters,
    ) -> atrium_xrpc::Result<
        crate::chat::bsky::moderation::get_actor_metadata::Output,
        crate::chat::bsky::moderation::get_actor_metadata::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::chat::bsky::moderation::get_actor_metadata::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn get_message_context(
        &self,
        params: crate::chat::bsky::moderation::get_message_context::Parameters,
    ) -> atrium_xrpc::Result<
        crate::chat::bsky::moderation::get_message_context::Output,
        crate::chat::bsky::moderation::get_message_context::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::chat::bsky::moderation::get_message_context::NSID
                        .into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn update_actor_access(
        &self,
        input: crate::chat::bsky::moderation::update_actor_access::Input,
    ) -> atrium_xrpc::Result<
        (),
        crate::chat::bsky::moderation::update_actor_access::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::chat::bsky::moderation::update_actor_access::NSID
                        .into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            atproto: com::atproto::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
impl<T> com::atproto::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            admin: com::atproto::admin::Service::new(std::sync::Arc::clone(&xrpc)),
            identity: com::atproto::identity::Service::new(std::sync::Arc::clone(&xrpc)),
            label: com::atproto::label::Service::new(std::sync::Arc::clone(&xrpc)),
            moderation: com::atproto::moderation::Service::new(
                std::sync::Arc::clone(&xrpc),
            ),
            repo: com::atproto::repo::Service::new(std::sync::Arc::clone(&xrpc)),
            server: com::atproto::server::Service::new(std::sync::Arc::clone(&xrpc)),
            sync: com::atproto::sync::Service::new(std::sync::Arc::clone(&xrpc)),
            temp: com::atproto::temp::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
impl<T> com::atproto::admin::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Delete a user account as an administrator.
    pub async fn delete_account(
        &self,
        input: crate::com::atproto::admin::delete_account::Input,
    ) -> atrium_xrpc::Result<(), crate::com::atproto::admin::delete_account::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::admin::delete_account::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Disable an account from receiving new invite codes, but does not invalidate existing codes.
    pub async fn disable_account_invites(
        &self,
        input: crate::com::atproto::admin::disable_account_invites::Input,
    ) -> atrium_xrpc::Result<
        (),
        crate::com::atproto::admin::disable_account_invites::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::admin::disable_account_invites::NSID
                        .into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Disable some set of codes and/or all codes associated with a set of users.
    pub async fn disable_invite_codes(
        &self,
        input: crate::com::atproto::admin::disable_invite_codes::Input,
    ) -> atrium_xrpc::Result<
        (),
        crate::com::atproto::admin::disable_invite_codes::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::admin::disable_invite_codes::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Re-enable an account's ability to receive invite codes.
    pub async fn enable_account_invites(
        &self,
        input: crate::com::atproto::admin::enable_account_invites::Input,
    ) -> atrium_xrpc::Result<
        (),
        crate::com::atproto::admin::enable_account_invites::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::admin::enable_account_invites::NSID
                        .into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get details about an account.
    pub async fn get_account_info(
        &self,
        params: crate::com::atproto::admin::get_account_info::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::admin::get_account_info::Output,
        crate::com::atproto::admin::get_account_info::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::admin::get_account_info::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get details about some accounts.
    pub async fn get_account_infos(
        &self,
        params: crate::com::atproto::admin::get_account_infos::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::admin::get_account_infos::Output,
        crate::com::atproto::admin::get_account_infos::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::admin::get_account_infos::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get an admin view of invite codes.
    pub async fn get_invite_codes(
        &self,
        params: crate::com::atproto::admin::get_invite_codes::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::admin::get_invite_codes::Output,
        crate::com::atproto::admin::get_invite_codes::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::admin::get_invite_codes::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get the service-specific admin status of a subject (account, record, or blob).
    pub async fn get_subject_status(
        &self,
        params: crate::com::atproto::admin::get_subject_status::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::admin::get_subject_status::Output,
        crate::com::atproto::admin::get_subject_status::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::admin::get_subject_status::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get list of accounts that matches your search query.
    pub async fn search_accounts(
        &self,
        params: crate::com::atproto::admin::search_accounts::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::admin::search_accounts::Output,
        crate::com::atproto::admin::search_accounts::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::admin::search_accounts::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Send email to a user's account email address.
    pub async fn send_email(
        &self,
        input: crate::com::atproto::admin::send_email::Input,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::admin::send_email::Output,
        crate::com::atproto::admin::send_email::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::admin::send_email::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Administrative action to update an account's email.
    pub async fn update_account_email(
        &self,
        input: crate::com::atproto::admin::update_account_email::Input,
    ) -> atrium_xrpc::Result<
        (),
        crate::com::atproto::admin::update_account_email::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::admin::update_account_email::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Administrative action to update an account's handle.
    pub async fn update_account_handle(
        &self,
        input: crate::com::atproto::admin::update_account_handle::Input,
    ) -> atrium_xrpc::Result<
        (),
        crate::com::atproto::admin::update_account_handle::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::admin::update_account_handle::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Update the password for a user account as an administrator.
    pub async fn update_account_password(
        &self,
        input: crate::com::atproto::admin::update_account_password::Input,
    ) -> atrium_xrpc::Result<
        (),
        crate::com::atproto::admin::update_account_password::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::admin::update_account_password::NSID
                        .into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Update the service-specific admin status of a subject (account, record, or blob).
    pub async fn update_subject_status(
        &self,
        input: crate::com::atproto::admin::update_subject_status::Input,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::admin::update_subject_status::Output,
        crate::com::atproto::admin::update_subject_status::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::admin::update_subject_status::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::identity::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Describe the credentials that should be included in the DID doc of an account that is migrating to this service.
    pub async fn get_recommended_did_credentials(
        &self,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::identity::get_recommended_did_credentials::Output,
        crate::com::atproto::identity::get_recommended_did_credentials::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::identity::get_recommended_did_credentials::NSID
                        .into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Request an email with a code to in order to request a signed PLC operation. Requires Auth.
    pub async fn request_plc_operation_signature(
        &self,
    ) -> atrium_xrpc::Result<
        (),
        crate::com::atproto::identity::request_plc_operation_signature::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::identity::request_plc_operation_signature::NSID
                        .into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Resolves a handle (domain name) to a DID.
    pub async fn resolve_handle(
        &self,
        params: crate::com::atproto::identity::resolve_handle::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::identity::resolve_handle::Output,
        crate::com::atproto::identity::resolve_handle::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::identity::resolve_handle::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Signs a PLC operation to update some value(s) in the requesting DID's document.
    pub async fn sign_plc_operation(
        &self,
        input: crate::com::atproto::identity::sign_plc_operation::Input,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::identity::sign_plc_operation::Output,
        crate::com::atproto::identity::sign_plc_operation::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::identity::sign_plc_operation::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Validates a PLC operation to ensure that it doesn't violate a service's constraints or get the identity into a bad state, then submits it to the PLC registry
    pub async fn submit_plc_operation(
        &self,
        input: crate::com::atproto::identity::submit_plc_operation::Input,
    ) -> atrium_xrpc::Result<
        (),
        crate::com::atproto::identity::submit_plc_operation::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::identity::submit_plc_operation::NSID
                        .into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Updates the current account's handle. Verifies handle validity, and updates did:plc document if necessary. Implemented by PDS, and requires auth.
    pub async fn update_handle(
        &self,
        input: crate::com::atproto::identity::update_handle::Input,
    ) -> atrium_xrpc::Result<(), crate::com::atproto::identity::update_handle::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::identity::update_handle::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::label::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Find labels relevant to the provided AT-URI patterns. Public endpoint for moderation services, though may return different or additional results with auth.
    pub async fn query_labels(
        &self,
        params: crate::com::atproto::label::query_labels::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::label::query_labels::Output,
        crate::com::atproto::label::query_labels::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::label::query_labels::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::moderation::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Submit a moderation report regarding an atproto account or record. Implemented by moderation services (with PDS proxying), and requires auth.
    pub async fn create_report(
        &self,
        input: crate::com::atproto::moderation::create_report::Input,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::moderation::create_report::Output,
        crate::com::atproto::moderation::create_report::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::moderation::create_report::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::repo::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Apply a batch transaction of repository creates, updates, and deletes. Requires auth, implemented by PDS.
    pub async fn apply_writes(
        &self,
        input: crate::com::atproto::repo::apply_writes::Input,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::repo::apply_writes::Output,
        crate::com::atproto::repo::apply_writes::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::repo::apply_writes::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Create a single new repository record. Requires auth, implemented by PDS.
    pub async fn create_record(
        &self,
        input: crate::com::atproto::repo::create_record::Input,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::repo::create_record::Output,
        crate::com::atproto::repo::create_record::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::repo::create_record::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Delete a repository record, or ensure it doesn't exist. Requires auth, implemented by PDS.
    pub async fn delete_record(
        &self,
        input: crate::com::atproto::repo::delete_record::Input,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::repo::delete_record::Output,
        crate::com::atproto::repo::delete_record::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::repo::delete_record::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get information about an account and repository, including the list of collections. Does not require auth.
    pub async fn describe_repo(
        &self,
        params: crate::com::atproto::repo::describe_repo::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::repo::describe_repo::Output,
        crate::com::atproto::repo::describe_repo::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::repo::describe_repo::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get a single record from a repository. Does not require auth.
    pub async fn get_record(
        &self,
        params: crate::com::atproto::repo::get_record::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::repo::get_record::Output,
        crate::com::atproto::repo::get_record::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::repo::get_record::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Import a repo in the form of a CAR file. Requires Content-Length HTTP header to be set.
    pub async fn import_repo(
        &self,
        input: Vec<u8>,
    ) -> atrium_xrpc::Result<(), crate::com::atproto::repo::import_repo::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                Vec<u8>,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::repo::import_repo::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Bytes(input)),
                    encoding: Some(String::from("application/vnd.ipld.car")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Returns a list of missing blobs for the requesting account. Intended to be used in the account migration flow.
    pub async fn list_missing_blobs(
        &self,
        params: crate::com::atproto::repo::list_missing_blobs::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::repo::list_missing_blobs::Output,
        crate::com::atproto::repo::list_missing_blobs::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::repo::list_missing_blobs::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///List a range of records in a repository, matching a specific collection. Does not require auth.
    pub async fn list_records(
        &self,
        params: crate::com::atproto::repo::list_records::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::repo::list_records::Output,
        crate::com::atproto::repo::list_records::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::repo::list_records::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Write a repository record, creating or updating it as needed. Requires auth, implemented by PDS.
    pub async fn put_record(
        &self,
        input: crate::com::atproto::repo::put_record::Input,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::repo::put_record::Output,
        crate::com::atproto::repo::put_record::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::repo::put_record::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Upload a new blob, to be referenced from a repository record. The blob will be deleted if it is not referenced within a time window (eg, minutes). Blob restrictions (mimetype, size, etc) are enforced when the reference is created. Requires auth, implemented by PDS.
    pub async fn upload_blob(
        &self,
        input: Vec<u8>,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::repo::upload_blob::Output,
        crate::com::atproto::repo::upload_blob::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                Vec<u8>,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::repo::upload_blob::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Bytes(input)),
                    encoding: Some(String::from("*/*")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::server::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Activates a currently deactivated account. Used to finalize account migration after the account's repo is imported and identity is setup.
    pub async fn activate_account(
        &self,
    ) -> atrium_xrpc::Result<(), crate::com::atproto::server::activate_account::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::server::activate_account::NSID.into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Returns the status of an account, especially as pertaining to import or recovery. Can be called many times over the course of an account migration. Requires auth and can only be called pertaining to oneself.
    pub async fn check_account_status(
        &self,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::server::check_account_status::Output,
        crate::com::atproto::server::check_account_status::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::server::check_account_status::NSID.into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Confirm an email using a token from com.atproto.server.requestEmailConfirmation.
    pub async fn confirm_email(
        &self,
        input: crate::com::atproto::server::confirm_email::Input,
    ) -> atrium_xrpc::Result<(), crate::com::atproto::server::confirm_email::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::server::confirm_email::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Create an account. Implemented by PDS.
    pub async fn create_account(
        &self,
        input: crate::com::atproto::server::create_account::Input,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::server::create_account::Output,
        crate::com::atproto::server::create_account::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::server::create_account::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Create an App Password.
    pub async fn create_app_password(
        &self,
        input: crate::com::atproto::server::create_app_password::Input,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::server::create_app_password::Output,
        crate::com::atproto::server::create_app_password::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::server::create_app_password::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Create an invite code.
    pub async fn create_invite_code(
        &self,
        input: crate::com::atproto::server::create_invite_code::Input,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::server::create_invite_code::Output,
        crate::com::atproto::server::create_invite_code::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::server::create_invite_code::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Create invite codes.
    pub async fn create_invite_codes(
        &self,
        input: crate::com::atproto::server::create_invite_codes::Input,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::server::create_invite_codes::Output,
        crate::com::atproto::server::create_invite_codes::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::server::create_invite_codes::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Create an authentication session.
    pub async fn create_session(
        &self,
        input: crate::com::atproto::server::create_session::Input,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::server::create_session::Output,
        crate::com::atproto::server::create_session::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::server::create_session::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Deactivates a currently active account. Stops serving of repo, and future writes to repo until reactivated. Used to finalize account migration with the old host after the account has been activated on the new host.
    pub async fn deactivate_account(
        &self,
        input: crate::com::atproto::server::deactivate_account::Input,
    ) -> atrium_xrpc::Result<
        (),
        crate::com::atproto::server::deactivate_account::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::server::deactivate_account::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Delete an actor's account with a token and password. Can only be called after requesting a deletion token. Requires auth.
    pub async fn delete_account(
        &self,
        input: crate::com::atproto::server::delete_account::Input,
    ) -> atrium_xrpc::Result<(), crate::com::atproto::server::delete_account::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::server::delete_account::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Delete the current session. Requires auth.
    pub async fn delete_session(
        &self,
    ) -> atrium_xrpc::Result<(), crate::com::atproto::server::delete_session::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::server::delete_session::NSID.into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Describes the server's account creation requirements and capabilities. Implemented by PDS.
    pub async fn describe_server(
        &self,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::server::describe_server::Output,
        crate::com::atproto::server::describe_server::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::server::describe_server::NSID.into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get all invite codes for the current account. Requires auth.
    pub async fn get_account_invite_codes(
        &self,
        params: crate::com::atproto::server::get_account_invite_codes::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::server::get_account_invite_codes::Output,
        crate::com::atproto::server::get_account_invite_codes::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::server::get_account_invite_codes::NSID
                        .into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get a signed token on behalf of the requesting DID for the requested service.
    pub async fn get_service_auth(
        &self,
        params: crate::com::atproto::server::get_service_auth::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::server::get_service_auth::Output,
        crate::com::atproto::server::get_service_auth::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::server::get_service_auth::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get information about the current auth session. Requires auth.
    pub async fn get_session(
        &self,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::server::get_session::Output,
        crate::com::atproto::server::get_session::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::server::get_session::NSID.into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///List all App Passwords.
    pub async fn list_app_passwords(
        &self,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::server::list_app_passwords::Output,
        crate::com::atproto::server::list_app_passwords::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::server::list_app_passwords::NSID.into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Refresh an authentication session. Requires auth using the 'refreshJwt' (not the 'accessJwt').
    pub async fn refresh_session(
        &self,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::server::refresh_session::Output,
        crate::com::atproto::server::refresh_session::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::server::refresh_session::NSID.into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Initiate a user account deletion via email.
    pub async fn request_account_delete(
        &self,
    ) -> atrium_xrpc::Result<
        (),
        crate::com::atproto::server::request_account_delete::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::server::request_account_delete::NSID
                        .into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Request an email with a code to confirm ownership of email.
    pub async fn request_email_confirmation(
        &self,
    ) -> atrium_xrpc::Result<
        (),
        crate::com::atproto::server::request_email_confirmation::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::server::request_email_confirmation::NSID
                        .into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Request a token in order to update email.
    pub async fn request_email_update(
        &self,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::server::request_email_update::Output,
        crate::com::atproto::server::request_email_update::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::server::request_email_update::NSID.into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Initiate a user account password reset via email.
    pub async fn request_password_reset(
        &self,
        input: crate::com::atproto::server::request_password_reset::Input,
    ) -> atrium_xrpc::Result<
        (),
        crate::com::atproto::server::request_password_reset::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::server::request_password_reset::NSID
                        .into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Reserve a repo signing key, for use with account creation. Necessary so that a DID PLC update operation can be constructed during an account migraiton. Public and does not require auth; implemented by PDS. NOTE: this endpoint may change when full account migration is implemented.
    pub async fn reserve_signing_key(
        &self,
        input: crate::com::atproto::server::reserve_signing_key::Input,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::server::reserve_signing_key::Output,
        crate::com::atproto::server::reserve_signing_key::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::server::reserve_signing_key::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Reset a user account password using a token.
    pub async fn reset_password(
        &self,
        input: crate::com::atproto::server::reset_password::Input,
    ) -> atrium_xrpc::Result<(), crate::com::atproto::server::reset_password::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::server::reset_password::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Revoke an App Password by name.
    pub async fn revoke_app_password(
        &self,
        input: crate::com::atproto::server::revoke_app_password::Input,
    ) -> atrium_xrpc::Result<
        (),
        crate::com::atproto::server::revoke_app_password::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::server::revoke_app_password::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Update an account's email.
    pub async fn update_email(
        &self,
        input: crate::com::atproto::server::update_email::Input,
    ) -> atrium_xrpc::Result<(), crate::com::atproto::server::update_email::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::server::update_email::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::sync::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Get a blob associated with a given account. Returns the full blob as originally uploaded. Does not require auth; implemented by PDS.
    pub async fn get_blob(
        &self,
        params: crate::com::atproto::sync::get_blob::Parameters,
    ) -> atrium_xrpc::Result<Vec<u8>, crate::com::atproto::sync::get_blob::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::sync::get_blob::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(bytes) => Ok(bytes),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get data blocks from a given repo, by CID. For example, intermediate MST nodes, or records. Does not require auth; implemented by PDS.
    pub async fn get_blocks(
        &self,
        params: crate::com::atproto::sync::get_blocks::Parameters,
    ) -> atrium_xrpc::Result<Vec<u8>, crate::com::atproto::sync::get_blocks::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::sync::get_blocks::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(bytes) => Ok(bytes),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///DEPRECATED - please use com.atproto.sync.getRepo instead
    pub async fn get_checkout(
        &self,
        params: crate::com::atproto::sync::get_checkout::Parameters,
    ) -> atrium_xrpc::Result<Vec<u8>, crate::com::atproto::sync::get_checkout::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::sync::get_checkout::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(bytes) => Ok(bytes),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///DEPRECATED - please use com.atproto.sync.getLatestCommit instead
    pub async fn get_head(
        &self,
        params: crate::com::atproto::sync::get_head::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::sync::get_head::Output,
        crate::com::atproto::sync::get_head::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::sync::get_head::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get the current commit CID & revision of the specified repo. Does not require auth.
    pub async fn get_latest_commit(
        &self,
        params: crate::com::atproto::sync::get_latest_commit::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::sync::get_latest_commit::Output,
        crate::com::atproto::sync::get_latest_commit::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::sync::get_latest_commit::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get data blocks needed to prove the existence or non-existence of record in the current version of repo. Does not require auth.
    pub async fn get_record(
        &self,
        params: crate::com::atproto::sync::get_record::Parameters,
    ) -> atrium_xrpc::Result<Vec<u8>, crate::com::atproto::sync::get_record::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::sync::get_record::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(bytes) => Ok(bytes),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Download a repository export as CAR file. Optionally only a 'diff' since a previous revision. Does not require auth; implemented by PDS.
    pub async fn get_repo(
        &self,
        params: crate::com::atproto::sync::get_repo::Parameters,
    ) -> atrium_xrpc::Result<Vec<u8>, crate::com::atproto::sync::get_repo::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::sync::get_repo::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(bytes) => Ok(bytes),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get the hosting status for a repository, on this server. Expected to be implemented by PDS and Relay.
    pub async fn get_repo_status(
        &self,
        params: crate::com::atproto::sync::get_repo_status::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::sync::get_repo_status::Output,
        crate::com::atproto::sync::get_repo_status::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::sync::get_repo_status::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///List blob CIDs for an account, since some repo revision. Does not require auth; implemented by PDS.
    pub async fn list_blobs(
        &self,
        params: crate::com::atproto::sync::list_blobs::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::sync::list_blobs::Output,
        crate::com::atproto::sync::list_blobs::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::sync::list_blobs::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Enumerates all the DID, rev, and commit CID for all repos hosted by this service. Does not require auth; implemented by PDS and Relay.
    pub async fn list_repos(
        &self,
        params: crate::com::atproto::sync::list_repos::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::sync::list_repos::Output,
        crate::com::atproto::sync::list_repos::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::sync::list_repos::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Enumerates all the DIDs which have records with the given collection NSID.
    pub async fn list_repos_by_collection(
        &self,
        params: crate::com::atproto::sync::list_repos_by_collection::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::sync::list_repos_by_collection::Output,
        crate::com::atproto::sync::list_repos_by_collection::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::sync::list_repos_by_collection::NSID
                        .into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Notify a crawling service of a recent update, and that crawling should resume. Intended use is after a gap between repo stream events caused the crawling service to disconnect. Does not require auth; implemented by Relay.
    pub async fn notify_of_update(
        &self,
        input: crate::com::atproto::sync::notify_of_update::Input,
    ) -> atrium_xrpc::Result<(), crate::com::atproto::sync::notify_of_update::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::sync::notify_of_update::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Request a service to persistently crawl hosted repos. Expected use is new PDS instances declaring their existence to Relays. Does not require auth.
    pub async fn request_crawl(
        &self,
        input: crate::com::atproto::sync::request_crawl::Input,
    ) -> atrium_xrpc::Result<(), crate::com::atproto::sync::request_crawl::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::sync::request_crawl::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> com::atproto::temp::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Add a handle to the set of reserved handles.
    pub async fn add_reserved_handle(
        &self,
        input: crate::com::atproto::temp::add_reserved_handle::Input,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::temp::add_reserved_handle::Output,
        crate::com::atproto::temp::add_reserved_handle::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::temp::add_reserved_handle::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Check accounts location in signup queue.
    pub async fn check_signup_queue(
        &self,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::temp::check_signup_queue::Output,
        crate::com::atproto::temp::check_signup_queue::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::temp::check_signup_queue::NSID.into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///DEPRECATED: use queryLabels or subscribeLabels instead -- Fetch all labels from a labeler created after a certain date.
    pub async fn fetch_labels(
        &self,
        params: crate::com::atproto::temp::fetch_labels::Parameters,
    ) -> atrium_xrpc::Result<
        crate::com::atproto::temp::fetch_labels::Output,
        crate::com::atproto::temp::fetch_labels::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::com::atproto::temp::fetch_labels::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Request a verification code to be sent to the supplied phone number
    pub async fn request_phone_verification(
        &self,
        input: crate::com::atproto::temp::request_phone_verification::Input,
    ) -> atrium_xrpc::Result<
        (),
        crate::com::atproto::temp::request_phone_verification::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::com::atproto::temp::request_phone_verification::NSID
                        .into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> fm::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            teal: fm::teal::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
impl<T> fm::teal::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            alpha: fm::teal::alpha::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
impl<T> fm::teal::alpha::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            actor: fm::teal::alpha::actor::Service::new(std::sync::Arc::clone(&xrpc)),
            feed: fm::teal::alpha::feed::Service::new(std::sync::Arc::clone(&xrpc)),
            stats: fm::teal::alpha::stats::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
impl<T> fm::teal::alpha::actor::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    pub async fn get_profile(
        &self,
        params: crate::fm::teal::alpha::actor::get_profile::Parameters,
    ) -> atrium_xrpc::Result<
        crate::fm::teal::alpha::actor::get_profile::Output,
        crate::fm::teal::alpha::actor::get_profile::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::fm::teal::alpha::actor::get_profile::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn get_profiles(
        &self,
        params: crate::fm::teal::alpha::actor::get_profiles::Parameters,
    ) -> atrium_xrpc::Result<
        crate::fm::teal::alpha::actor::get_profiles::Output,
        crate::fm::teal::alpha::actor::get_profiles::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::fm::teal::alpha::actor::get_profiles::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn search_actors(
        &self,
        params: crate::fm::teal::alpha::actor::search_actors::Parameters,
    ) -> atrium_xrpc::Result<
        crate::fm::teal::alpha::actor::search_actors::Output,
        crate::fm::teal::alpha::actor::search_actors::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::fm::teal::alpha::actor::search_actors::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> fm::teal::alpha::feed::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    pub async fn get_actor_feed(
        &self,
        params: crate::fm::teal::alpha::feed::get_actor_feed::Parameters,
    ) -> atrium_xrpc::Result<
        crate::fm::teal::alpha::feed::get_actor_feed::Output,
        crate::fm::teal::alpha::feed::get_actor_feed::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::fm::teal::alpha::feed::get_actor_feed::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn get_play(
        &self,
        params: crate::fm::teal::alpha::feed::get_play::Parameters,
    ) -> atrium_xrpc::Result<
        crate::fm::teal::alpha::feed::get_play::Output,
        crate::fm::teal::alpha::feed::get_play::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::fm::teal::alpha::feed::get_play::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> fm::teal::alpha::stats::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Get latest plays globally
    pub async fn get_latest(
        &self,
        params: crate::fm::teal::alpha::stats::get_latest::Parameters,
    ) -> atrium_xrpc::Result<
        crate::fm::teal::alpha::stats::get_latest::Output,
        crate::fm::teal::alpha::stats::get_latest::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::fm::teal::alpha::stats::get_latest::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn get_top_artists(
        &self,
        params: crate::fm::teal::alpha::stats::get_top_artists::Parameters,
    ) -> atrium_xrpc::Result<
        crate::fm::teal::alpha::stats::get_top_artists::Output,
        crate::fm::teal::alpha::stats::get_top_artists::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::fm::teal::alpha::stats::get_top_artists::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn get_top_releases(
        &self,
        params: crate::fm::teal::alpha::stats::get_top_releases::Parameters,
    ) -> atrium_xrpc::Result<
        crate::fm::teal::alpha::stats::get_top_releases::Output,
        crate::fm::teal::alpha::stats::get_top_releases::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::fm::teal::alpha::stats::get_top_releases::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn get_user_top_artists(
        &self,
        params: crate::fm::teal::alpha::stats::get_user_top_artists::Parameters,
    ) -> atrium_xrpc::Result<
        crate::fm::teal::alpha::stats::get_user_top_artists::Output,
        crate::fm::teal::alpha::stats::get_user_top_artists::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::fm::teal::alpha::stats::get_user_top_artists::NSID
                        .into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    pub async fn get_user_top_releases(
        &self,
        params: crate::fm::teal::alpha::stats::get_user_top_releases::Parameters,
    ) -> atrium_xrpc::Result<
        crate::fm::teal::alpha::stats::get_user_top_releases::Output,
        crate::fm::teal::alpha::stats::get_user_top_releases::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::fm::teal::alpha::stats::get_user_top_releases::NSID
                        .into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> tools::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            ozone: tools::ozone::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
impl<T> tools::ozone::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            communication: tools::ozone::communication::Service::new(
                std::sync::Arc::clone(&xrpc),
            ),
            moderation: tools::ozone::moderation::Service::new(
                std::sync::Arc::clone(&xrpc),
            ),
            server: tools::ozone::server::Service::new(std::sync::Arc::clone(&xrpc)),
            set: tools::ozone::set::Service::new(std::sync::Arc::clone(&xrpc)),
            setting: tools::ozone::setting::Service::new(std::sync::Arc::clone(&xrpc)),
            signature: tools::ozone::signature::Service::new(
                std::sync::Arc::clone(&xrpc),
            ),
            team: tools::ozone::team::Service::new(std::sync::Arc::clone(&xrpc)),
            _phantom: core::marker::PhantomData,
        }
    }
}
impl<T> tools::ozone::communication::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Administrative action to create a new, re-usable communication (email for now) template.
    pub async fn create_template(
        &self,
        input: crate::tools::ozone::communication::create_template::Input,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::communication::create_template::Output,
        crate::tools::ozone::communication::create_template::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::tools::ozone::communication::create_template::NSID
                        .into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Delete a communication template.
    pub async fn delete_template(
        &self,
        input: crate::tools::ozone::communication::delete_template::Input,
    ) -> atrium_xrpc::Result<
        (),
        crate::tools::ozone::communication::delete_template::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::tools::ozone::communication::delete_template::NSID
                        .into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get list of all communication templates.
    pub async fn list_templates(
        &self,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::communication::list_templates::Output,
        crate::tools::ozone::communication::list_templates::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::tools::ozone::communication::list_templates::NSID
                        .into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Administrative action to update an existing communication template. Allows passing partial fields to patch specific fields only.
    pub async fn update_template(
        &self,
        input: crate::tools::ozone::communication::update_template::Input,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::communication::update_template::Output,
        crate::tools::ozone::communication::update_template::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::tools::ozone::communication::update_template::NSID
                        .into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> tools::ozone::moderation::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Take a moderation action on an actor.
    pub async fn emit_event(
        &self,
        input: crate::tools::ozone::moderation::emit_event::Input,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::moderation::emit_event::Output,
        crate::tools::ozone::moderation::emit_event::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::tools::ozone::moderation::emit_event::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get details about a moderation event.
    pub async fn get_event(
        &self,
        params: crate::tools::ozone::moderation::get_event::Parameters,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::moderation::get_event::Output,
        crate::tools::ozone::moderation::get_event::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::tools::ozone::moderation::get_event::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get details about a record.
    pub async fn get_record(
        &self,
        params: crate::tools::ozone::moderation::get_record::Parameters,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::moderation::get_record::Output,
        crate::tools::ozone::moderation::get_record::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::tools::ozone::moderation::get_record::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get details about some records.
    pub async fn get_records(
        &self,
        params: crate::tools::ozone::moderation::get_records::Parameters,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::moderation::get_records::Output,
        crate::tools::ozone::moderation::get_records::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::tools::ozone::moderation::get_records::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get details about a repository.
    pub async fn get_repo(
        &self,
        params: crate::tools::ozone::moderation::get_repo::Parameters,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::moderation::get_repo::Output,
        crate::tools::ozone::moderation::get_repo::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::tools::ozone::moderation::get_repo::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get reporter stats for a list of users.
    pub async fn get_reporter_stats(
        &self,
        params: crate::tools::ozone::moderation::get_reporter_stats::Parameters,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::moderation::get_reporter_stats::Output,
        crate::tools::ozone::moderation::get_reporter_stats::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::tools::ozone::moderation::get_reporter_stats::NSID
                        .into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get details about some repositories.
    pub async fn get_repos(
        &self,
        params: crate::tools::ozone::moderation::get_repos::Parameters,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::moderation::get_repos::Output,
        crate::tools::ozone::moderation::get_repos::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::tools::ozone::moderation::get_repos::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///List moderation events related to a subject.
    pub async fn query_events(
        &self,
        params: crate::tools::ozone::moderation::query_events::Parameters,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::moderation::query_events::Output,
        crate::tools::ozone::moderation::query_events::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::tools::ozone::moderation::query_events::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///View moderation statuses of subjects (record or repo).
    pub async fn query_statuses(
        &self,
        params: crate::tools::ozone::moderation::query_statuses::Parameters,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::moderation::query_statuses::Output,
        crate::tools::ozone::moderation::query_statuses::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::tools::ozone::moderation::query_statuses::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Find repositories based on a search term.
    pub async fn search_repos(
        &self,
        params: crate::tools::ozone::moderation::search_repos::Parameters,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::moderation::search_repos::Output,
        crate::tools::ozone::moderation::search_repos::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::tools::ozone::moderation::search_repos::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> tools::ozone::server::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Get details about ozone's server configuration.
    pub async fn get_config(
        &self,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::server::get_config::Output,
        crate::tools::ozone::server::get_config::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::tools::ozone::server::get_config::NSID.into(),
                    parameters: None,
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> tools::ozone::set::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Add values to a specific set. Attempting to add values to a set that does not exist will result in an error.
    pub async fn add_values(
        &self,
        input: crate::tools::ozone::set::add_values::Input,
    ) -> atrium_xrpc::Result<(), crate::tools::ozone::set::add_values::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::tools::ozone::set::add_values::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Delete an entire set. Attempting to delete a set that does not exist will result in an error.
    pub async fn delete_set(
        &self,
        input: crate::tools::ozone::set::delete_set::Input,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::set::delete_set::Output,
        crate::tools::ozone::set::delete_set::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::tools::ozone::set::delete_set::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Delete values from a specific set. Attempting to delete values that are not in the set will not result in an error
    pub async fn delete_values(
        &self,
        input: crate::tools::ozone::set::delete_values::Input,
    ) -> atrium_xrpc::Result<(), crate::tools::ozone::set::delete_values::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::tools::ozone::set::delete_values::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get a specific set and its values
    pub async fn get_values(
        &self,
        params: crate::tools::ozone::set::get_values::Parameters,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::set::get_values::Output,
        crate::tools::ozone::set::get_values::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::tools::ozone::set::get_values::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Query available sets
    pub async fn query_sets(
        &self,
        params: crate::tools::ozone::set::query_sets::Parameters,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::set::query_sets::Output,
        crate::tools::ozone::set::query_sets::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::tools::ozone::set::query_sets::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Create or update set metadata
    pub async fn upsert_set(
        &self,
        input: crate::tools::ozone::set::upsert_set::Input,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::set::upsert_set::Output,
        crate::tools::ozone::set::upsert_set::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::tools::ozone::set::upsert_set::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> tools::ozone::setting::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///List settings with optional filtering
    pub async fn list_options(
        &self,
        params: crate::tools::ozone::setting::list_options::Parameters,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::setting::list_options::Output,
        crate::tools::ozone::setting::list_options::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::tools::ozone::setting::list_options::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Delete settings by key
    pub async fn remove_options(
        &self,
        input: crate::tools::ozone::setting::remove_options::Input,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::setting::remove_options::Output,
        crate::tools::ozone::setting::remove_options::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::tools::ozone::setting::remove_options::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Create or update setting option
    pub async fn upsert_option(
        &self,
        input: crate::tools::ozone::setting::upsert_option::Input,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::setting::upsert_option::Output,
        crate::tools::ozone::setting::upsert_option::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::tools::ozone::setting::upsert_option::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> tools::ozone::signature::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Find all correlated threat signatures between 2 or more accounts.
    pub async fn find_correlation(
        &self,
        params: crate::tools::ozone::signature::find_correlation::Parameters,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::signature::find_correlation::Output,
        crate::tools::ozone::signature::find_correlation::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::tools::ozone::signature::find_correlation::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Get accounts that share some matching threat signatures with the root account.
    pub async fn find_related_accounts(
        &self,
        params: crate::tools::ozone::signature::find_related_accounts::Parameters,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::signature::find_related_accounts::Output,
        crate::tools::ozone::signature::find_related_accounts::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::tools::ozone::signature::find_related_accounts::NSID
                        .into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Search for accounts that match one or more threat signature values.
    pub async fn search_accounts(
        &self,
        params: crate::tools::ozone::signature::search_accounts::Parameters,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::signature::search_accounts::Output,
        crate::tools::ozone::signature::search_accounts::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::tools::ozone::signature::search_accounts::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
impl<T> tools::ozone::team::Service<T>
where
    T: atrium_xrpc::XrpcClient + Send + Sync,
{
    #[allow(unused_variables)]
    pub(crate) fn new(xrpc: std::sync::Arc<T>) -> Self {
        Self {
            xrpc,
            _phantom: core::marker::PhantomData,
        }
    }
    ///Add a member to the ozone team. Requires admin role.
    pub async fn add_member(
        &self,
        input: crate::tools::ozone::team::add_member::Input,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::team::add_member::Output,
        crate::tools::ozone::team::add_member::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::tools::ozone::team::add_member::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Delete a member from ozone team. Requires admin role.
    pub async fn delete_member(
        &self,
        input: crate::tools::ozone::team::delete_member::Input,
    ) -> atrium_xrpc::Result<(), crate::tools::ozone::team::delete_member::Error> {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                (),
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::tools::ozone::team::delete_member::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Bytes(_) => Ok(()),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///List all members with access to the ozone service.
    pub async fn list_members(
        &self,
        params: crate::tools::ozone::team::list_members::Parameters,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::team::list_members::Output,
        crate::tools::ozone::team::list_members::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                _,
                (),
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::GET,
                    nsid: crate::tools::ozone::team::list_members::NSID.into(),
                    parameters: Some(params),
                    input: None,
                    encoding: None,
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
    ///Update a member in the ozone service. Requires admin role.
    pub async fn update_member(
        &self,
        input: crate::tools::ozone::team::update_member::Input,
    ) -> atrium_xrpc::Result<
        crate::tools::ozone::team::update_member::Output,
        crate::tools::ozone::team::update_member::Error,
    > {
        let response = self
            .xrpc
            .send_xrpc::<
                (),
                _,
                _,
                _,
            >(
                &atrium_xrpc::XrpcRequest {
                    method: http::Method::POST,
                    nsid: crate::tools::ozone::team::update_member::NSID.into(),
                    parameters: None,
                    input: Some(atrium_xrpc::InputDataOrBytes::Data(input)),
                    encoding: Some(String::from("application/json")),
                },
            )
            .await?;
        match response {
            atrium_xrpc::OutputDataOrBytes::Data(data) => Ok(data),
            _ => Err(atrium_xrpc::Error::UnexpectedResponseType),
        }
    }
}
